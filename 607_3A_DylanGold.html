<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>607Assignment3A Dylan Gold</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="607_3A_DylanGold_files/libs/clipboard/clipboard.min.js"></script>
<script src="607_3A_DylanGold_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="607_3A_DylanGold_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="607_3A_DylanGold_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="607_3A_DylanGold_files/libs/quarto-html/popper.min.js"></script>
<script src="607_3A_DylanGold_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="607_3A_DylanGold_files/libs/quarto-html/anchor.min.js"></script>
<link href="607_3A_DylanGold_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="607_3A_DylanGold_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="607_3A_DylanGold_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="607_3A_DylanGold_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="607_3A_DylanGold_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">607Assignment3A Dylan Gold</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="assignment-3a-dylan-gold" class="level2">
<h2 class="anchored" data-anchor-id="assignment-3a-dylan-gold">607 Assignment 3A Dylan Gold</h2>
</section>
<section id="approach" class="level1">
<h1>Approach</h1>
<p>In this assignment we are making a rating system based on the ratings in assignment 2A or new data given. Initially I was pretty confused just looking off the xlsx document we had. Maybe I missed something there but I did not see much in the 4 tables in the document. After the class lecture though I understood a bit better.</p>
<p>I will use the data given to us. The data I collected is pretty high ratings cause I just picked shows that I liked, and my friends have discussed who also generally like. So it seems kind of biased for a global baseline.</p>
<p>From the lecture we break this down into these steps: Create baseline from average of all movies. Generate averages of users Generate averages of movies Create baseline user and movie averages from difference from overall baseline. Create specific unseen movies ratings from sum of baseline global,baseline user and baseline movie ratings. Perhaps recommend movie based on highest unseen for each user? (at least 1)</p>
<p>Ideally I can create a function that does this when given a data frame.</p>
</section>
<section id="codebase" class="level1">
<h1>Codebase:</h1>
<p>After setting up the data in github for the raw, I perform the usual setup for the R environment.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Getting data into data frame</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">"https://raw.githubusercontent.com/DylanGoldJ/607-Assignment-3/refs/heads/main/MovieRatings3A.csv"</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">file =</span> url,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">col_names =</span> <span class="cn">FALSE</span> <span class="co"># No headers in the csv, needed.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df, <span class="dv">10</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 × 7
   X1           X2    X3    X4    X5    X6    X7
   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
 1 Burton       NA    NA    NA     4    NA     4
 2 Charley       4     5     4     3     2     3
 3 Dan          NA     5    NA    NA    NA     5
 4 Dieudonne     5     4    NA    NA    NA     5
 5 Matt          4    NA     2    NA     2     5
 6 Mauricio      4    NA     3     3     4    NA
 7 Max           4     4     4     2     2     4
 8 Nathan       NA    NA    NA    NA    NA     4
 9 Param         4     4     1    NA    NA     5
10 Parshu        4     3     5     5     2     3</code></pre>
</div>
</div>
<p>The problem statement missed the headers, I put them back</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span> <span class="fu">set_names</span>(<span class="st">"Critic"</span>, <span class="st">"CaptainAmerica"</span>, <span class="st">"Deadpool"</span>, <span class="st">"Frozen"</span>, <span class="st">"JungleBook"</span>, <span class="st">"PitchPerfect2"</span>, <span class="st">"StarWarsForce"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(df, <span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 5 × 7
  Critic   CaptainAmerica Deadpool Frozen JungleBook PitchPerfect2 StarWarsForce
  &lt;chr&gt;             &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
1 Shipra               NA       NA      4          5            NA             3
2 Sreejaya              5        5      5          4             4             5
3 Steve                 4       NA     NA         NA            NA             4
4 Vuthy                 4        5      3          3             3            NA
5 Xingjia              NA       NA      5          5            NA            NA</code></pre>
</div>
</div>
<p>Now create baseline from average of all movies. Generate averages of users Generate averages of movies</p>
<p>Create a vector for the averages of the columns(Movie avg)</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># I create movies for easier selection</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>movies <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"CaptainAmerica"</span>, <span class="st">"Deadpool"</span>, <span class="st">"Frozen"</span>, <span class="st">"JungleBook"</span>, <span class="st">"PitchPerfect2"</span>, <span class="st">"StarWarsForce"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># This following line was kind of tricky for me. My understanding is ~ creates a function where the period is the input. across uses this function down the columns</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># The function we created with ~ is just get the mean with all the column values as input, we also specify the columns before hand.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>movie_avg <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span> <span class="fu">summarize</span>(<span class="fu">across</span>(<span class="fu">all_of</span>(movies), <span class="sc">~</span> <span class="fu">mean</span>(., <span class="at">na.rm =</span> <span class="cn">TRUE</span>)))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>movie_avg</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 6
  CaptainAmerica Deadpool Frozen JungleBook PitchPerfect2 StarWarsForce
           &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
1           4.27     4.44   3.73        3.9          2.71          4.15</code></pre>
</div>
</div>
<p>Get the user_mean</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>user_avg <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowwise</span>() <span class="sc">%&gt;%</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">user_mean =</span> <span class="fu">mean</span>(<span class="fu">c_across</span>(<span class="fu">all_of</span>(movies)), <span class="at">na.rm =</span> <span class="cn">TRUE</span>)) <span class="co">#c_across with rowwise to perform row-wise aggregations</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>user_avg</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 16 × 1
   user_mean
       &lt;dbl&gt;
 1      4   
 2      3.5 
 3      5   
 4      4.67
 5      3.25
 6      3.5 
 7      3.33
 8      4   
 9      3.5 
10      3.67
11      4.8 
12      4   
13      4.67
14      4   
15      3.6 
16      5   </code></pre>
</div>
</div>
<p>Lets combine this with the names for readability and usability We can use bind_col</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>user_avg <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(<span class="fu">select</span>(df, <span class="fu">c</span>(<span class="st">"Critic"</span>)), user_avg)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>user_avg</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 16 × 2
   Critic    user_mean
   &lt;chr&gt;         &lt;dbl&gt;
 1 Burton         4   
 2 Charley        3.5 
 3 Dan            5   
 4 Dieudonne      4.67
 5 Matt           3.25
 6 Mauricio       3.5 
 7 Max            3.33
 8 Nathan         4   
 9 Param          3.5 
10 Parshu         3.67
11 Prashanth      4.8 
12 Shipra         4   
13 Sreejaya       4.67
14 Steve          4   
15 Vuthy          3.6 
16 Xingjia        5   </code></pre>
</div>
</div>
<p>Now we get the global baseline average: From what I seen online we can just convert to a matrix for this</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>df_matrix <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">select</span>(df, movies)) <span class="co">#Create matrix, get rid of the column with character values</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.
ℹ Please use `all_of()` or `any_of()` instead.
  # Was:
  data %&gt;% select(movies)

  # Now:
  data %&gt;% select(all_of(movies))

See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>global_avg <span class="ot">&lt;-</span> <span class="fu">mean</span>(df_matrix, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>global_avg </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3.934426</code></pre>
</div>
</div>
<p>We now have the values for user_avg, movie_avg and global_avg. We can check with the excel file to double check our values and it seems alright.</p>
<p>Now we can calculate the movie scores for unseen movies. I will first create a function so we can apply it to the whole data frame. First a function that can create the estimate. I just give it everything for the sake of side-effects</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>create_estimate <span class="ot">&lt;-</span> <span class="cf">function</span>(user, movie, users_means, movies_means, global_mean){</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  user_val <span class="ot">&lt;-</span> <span class="fu">filter</span>(users_means, Critic <span class="sc">==</span> user) <span class="sc">%&gt;%</span> <span class="fu">select</span>(user_mean) <span class="sc">%&gt;%</span> <span class="fu">pull</span>() <span class="co"># Get user rating, filter cause data is multiple rows, select for mean only, pull</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  movie_val <span class="ot">&lt;-</span> <span class="fu">select</span>(movies_means, <span class="fu">all_of</span>(movie)) <span class="sc">%&gt;%</span> <span class="fu">pull</span>() <span class="co">#Get movie rating, select cause data is multiple columns. pull</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Now generate the baselines for both the user and movie</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  user_baseline <span class="ot">&lt;-</span> user_val <span class="sc">-</span> global_mean </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  movie_baseline <span class="ot">&lt;-</span> movie_val <span class="sc">-</span> global_mean</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  estimate <span class="ot">&lt;-</span> global_mean <span class="sc">+</span> movie_baseline <span class="sc">+</span> user_baseline <span class="co"># Use the formula. </span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">#estimate &lt;- user_val + movie_val - global_mean #Alternate formula kind of interesting</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(estimate)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="fu">create_estimate</span>(<span class="st">"Param"</span>, <span class="st">"PitchPerfect2"</span>, user_avg, movie_avg, global_avg)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.279859</code></pre>
</div>
</div>
<p>We can see that we created a function that works properly by comparing it to the example in the excel file.</p>
<p>This function will take the information we just calculated, the data frame and return a data frame with all the values filled in. I struggled to figure this out in dplyr. I believe that in dplyr you are encouraged to do either row OR column work at once. For doing stuff cell by cell it seemed like converting to a matrix was the best way.</p>
<p>I really tried to avoid a nested loop but I did not find how to do it while also keeping a reference to the current column and row. Perhaps this was a design flaw in my approach, or I could maybe bind the columns to the data frame or something but I already set up the previous function</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>create_estimate_df <span class="ot">&lt;-</span> <span class="cf">function</span>(df, users_mean, movies_mean, global_mean){</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  df_matrix <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(df)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  movie_names <span class="ot">&lt;-</span> <span class="fu">colnames</span>(df_matrix)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(df_matrix) <span class="ot">&lt;-</span> df_matrix[,<span class="st">"Critic"</span>] <span class="co"># Set the rownames of the matrix to the first column "Critics" column</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  critics <span class="ot">&lt;-</span> <span class="fu">rownames</span>(df_matrix)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (movie_name <span class="cf">in</span> movie_names[<span class="sc">-</span><span class="dv">1</span>]){ <span class="co"># Iterate Movies, cut critic column</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (critic <span class="cf">in</span> critics){ <span class="co"># Iterate Critics</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ifelse</span>(<span class="fu">is.na</span>(df_matrix[critic, movie_name]), <span class="co"># If element is null</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>             df_matrix[critic, movie_name] <span class="ot">&lt;-</span> <span class="fu">create_estimate</span>(critic, movie_name, user_avg, movie_avg, global_avg), <span class="co">#generate estimate</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>             df_matrix[critic, movie_name] <span class="ot">&lt;-</span> <span class="cn">NA</span>) <span class="co">#otherwise set NA</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  df_matrix <span class="ot">&lt;-</span><span class="fu">as.data.frame</span>(df_matrix) <span class="sc">%&gt;%</span> <span class="fu">select</span>(movies)<span class="co">#convert back to data frame, select movies because we duplicated a column(got rid of critic column for indexed by critic)</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(df_matrix)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>estimated_review <span class="ot">&lt;-</span> <span class="fu">create_estimate_df</span>(df, user_avg, movie_avg, global_avg)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(estimated_review)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>            CaptainAmerica         Deadpool           Frozen       JungleBook
Burton    4.33830104321908 4.51001821493625 3.79284649776453             &lt;NA&gt;
Charley               &lt;NA&gt;             &lt;NA&gt;             &lt;NA&gt;             &lt;NA&gt;
Dan       5.33830104321908             &lt;NA&gt; 4.79284649776453  4.9655737704918
Dieudonne             &lt;NA&gt;             &lt;NA&gt;  4.4595131644312 4.63224043715847
Matt                  &lt;NA&gt; 3.76001821493625             &lt;NA&gt;  3.2155737704918
Mauricio              &lt;NA&gt; 4.01001821493625             &lt;NA&gt;             &lt;NA&gt;
             PitchPerfect2    StarWarsForce
Burton    2.77985948477752             &lt;NA&gt;
Charley               &lt;NA&gt;             &lt;NA&gt;
Dan       3.77985948477752             &lt;NA&gt;
Dieudonne 3.44652615144418             &lt;NA&gt;
Matt                  &lt;NA&gt;             &lt;NA&gt;
Mauricio              &lt;NA&gt; 3.71941992433796</code></pre>
</div>
</div>
<p>We now have a matrix showing the generated scores. NA values are shows that they have already seen Finally we can go row wise to find the max score for each person.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Save rownames because tibble operations remove rownames(they are discouraged, we can add back as a column at the end after our work.)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>rec_movies <span class="ot">&lt;-</span> estimated_review <span class="sc">%&gt;%</span> </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames_to_column</span>(<span class="st">"Critic"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowwise</span>() <span class="sc">%&gt;%</span> <span class="co">#Row wise</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">any</span>(<span class="sc">!</span><span class="fu">is.na</span>(<span class="fu">c_across</span>(movies)))) <span class="sc">%&gt;%</span> <span class="co">#Which.max will error if a row is fully na, remove the rows that are NA</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">Recommended_Movie =</span> <span class="fu">colnames</span>(df)[<span class="fu">which.max</span>(<span class="fu">c_across</span>(movies))])  <span class="co">#Create new column, get max index, then use that index in col names to get the movie</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>rec_movies</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 12 × 8
# Rowwise: 
   Critic  CaptainAmerica Deadpool Frozen JungleBook PitchPerfect2 StarWarsForce
   &lt;chr&gt;   &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;        
 1 Burton  4.33830104321… 4.51001… 3.792… &lt;NA&gt;       2.7798594847… &lt;NA&gt;         
 2 Dan     5.33830104321… &lt;NA&gt;     4.792… 4.9655737… 3.7798594847… &lt;NA&gt;         
 3 Dieudo… &lt;NA&gt;           &lt;NA&gt;     4.459… 4.6322404… 3.4465261514… &lt;NA&gt;         
 4 Matt    &lt;NA&gt;           3.76001… &lt;NA&gt;   3.2155737… &lt;NA&gt;          &lt;NA&gt;         
 5 Mauric… &lt;NA&gt;           4.01001… &lt;NA&gt;   &lt;NA&gt;       &lt;NA&gt;          3.7194199243…
 6 Nathan  4.33830104321… 4.51001… 3.792… 3.9655737… 2.7798594847… &lt;NA&gt;         
 7 Param   &lt;NA&gt;           &lt;NA&gt;     &lt;NA&gt;   3.4655737… 2.2798594847… &lt;NA&gt;         
 8 Prasha… &lt;NA&gt;           &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;       3.5798594847… &lt;NA&gt;         
 9 Shipra  4.33830104321… 4.51001… &lt;NA&gt;   &lt;NA&gt;       2.7798594847… &lt;NA&gt;         
10 Steve   &lt;NA&gt;           4.51001… 3.792… 3.9655737… 2.7798594847… &lt;NA&gt;         
11 Vuthy   &lt;NA&gt;           &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;       &lt;NA&gt;          3.8194199243…
12 Xingjia 5.33830104321… 5.51001… &lt;NA&gt;   &lt;NA&gt;       3.7798594847… 5.2194199243…
# ℹ 1 more variable: Recommended_Movie &lt;chr&gt;</code></pre>
</div>
</div>
<p>We now have values for the predicted movie. I want to join this with the original while and having NA fill in for the values not in this. We should be able to just join for this to happen. We can use the original df as the anchor for the join. We just want the predicted movie column</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We get just the Critic and Predicted_Movie and join that to our original dataframe.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>ratings_with_recommendation<span class="ot">&lt;-</span> <span class="fu">left_join</span>(df, rec_movies[, <span class="fu">c</span>(<span class="st">"Critic"</span>, <span class="st">"Recommended_Movie"</span>)], <span class="st">"Critic"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>ratings_with_recommendation</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 16 × 8
   Critic  CaptainAmerica Deadpool Frozen JungleBook PitchPerfect2 StarWarsForce
   &lt;chr&gt;            &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
 1 Burton              NA       NA     NA          4            NA             4
 2 Charley              4        5      4          3             2             3
 3 Dan                 NA        5     NA         NA            NA             5
 4 Dieudo…              5        4     NA         NA            NA             5
 5 Matt                 4       NA      2         NA             2             5
 6 Mauric…              4       NA      3          3             4            NA
 7 Max                  4        4      4          2             2             4
 8 Nathan              NA       NA     NA         NA            NA             4
 9 Param                4        4      1         NA            NA             5
10 Parshu               4        3      5          5             2             3
11 Prasha…              5        5      5          5            NA             4
12 Shipra              NA       NA      4          5            NA             3
13 Sreeja…              5        5      5          4             4             5
14 Steve                4       NA     NA         NA            NA             4
15 Vuthy                4        5      3          3             3            NA
16 Xingjia             NA       NA      5          5            NA            NA
# ℹ 1 more variable: Recommended_Movie &lt;chr&gt;</code></pre>
</div>
</div>
<p>We now have the recommended movie for all users who did not see all the movies. The ones who did see all movies have NA as their Recommended Movie</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>In this assignment we were able to heavily modify a data frame based on a given algorithm. By breaking the algorithm into different steps we were able to sequentially create different values needed to generate an estimate for each movie each user has not seen yet. With this we could find the movie that would be most suggested to them based on the algorithm. Some ways I could add on to this is make the whole things more modular such that when any data frame with the same format is put in, it can generate the most recommended movie for each user. I also feel like the double looping with a matrix may have been a bit poor and maybe there is a better way to do that in the future.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>